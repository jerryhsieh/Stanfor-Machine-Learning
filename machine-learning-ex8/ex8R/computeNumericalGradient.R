computeNumericalGradient<-function (param, theta) {
#COMPUTENUMERICALGRADIENT Computes the gradient using "finite differences"
#and gives us a numerical estimate of the gradient.
#   numgrad = COMPUTENUMERICALGRADIENT(J, theta) computes the numerical
#   gradient of the function J around theta. Calling y = J(theta) should
#   return the function value at theta.

# Notes: The following code implements numerical gradient checking, and 
#        returns the numerical gradient.It sets numgrad(i) to (a numerical 
#        approximation of) the partial derivative of J with respect to the 
#        i-th input argument, evaluated at theta. (i.e., numgrad(i) should 
#        be the (approximately) the partial derivative of J with respect 
#        to theta(i).)
#                
    
    
    numgrad <- rep(0, length(theta))
    perturb <- rep(0, length(theta))
    e <- 0.0001
    
    Y <- param[[1]]
    R <- param[[2]]
    num_users <- unlist(param[3])
    num_movies <- unlist(param[4])
    num_features <- unlist(param[5])
    lambda <- unlist(param[6])
       
    for (p in 1:length(theta)) {
# Set perturbation vector
        perturb[p] = e
        loss1 = cofiCostFunc((theta - perturb), Y, R, num_users, num_movies, num_features, lambda)[1]
        loss2 = cofiCostFunc((theta + perturb), Y, R, num_users, num_movies, num_features, lambda)[1]
# Compute Numerical Gradient
        numgrad[p] = (loss2[[1]] - loss1[[1]]) / (2*e)
        perturb[p] = 0
    }

    return(numgrad)
}